[{"ver":"0.1","info":{"id":"ltBGWh","date":"1428443031","viewed":6137,"name":"Gargantua Render","username":"koiava","description":"Rendering black hole with gravitational lensing","likes":75,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","blackhole","gravitationallensing"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"XdfGRn","filepath":"\/media\/a\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","previewfilepath":"\/media\/ap\/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg","type":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1},{"id":"Xsf3zn","filepath":"\/media\/a\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","previewfilepath":"\/media\/ap\/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/This is simple render of black hole with gravitational lensing\n\/\/Rendering participating media is one of the most complecated part of production rendering\n\/\/and rendering heterogenious particifating media illuminated from heterogenious volumetric\n\/\/light sorce within gravitational lensing is practically imposible in significant frame rates.\n\/\/So I decided to implement only lensing part. lighting isn't calculated.\n\n\n\/\/random number and cloud generation is taken from iq :)\nfloat seed;\t\/\/seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\/\/***********************************\n\n\/\/used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define HALF_PI \t\t\t1.5707963\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.00001 \n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n\n\/\/Increase SPP to remove noise :)\n#define SPP 4\n#define GRAVITATIONAL_LENSING\n\nstruct Ray {\n    vec3 origin;\n    vec3 dir;\n};\n\nstruct Camera {\n    mat3 rotate;\n\tvec3 pos;\n    vec3 target;\n    float fovV;\n};\n\nstruct BlackHole {\n    vec3 position_;\n    float radius_;\n    float ring_radius_inner_;\n    float ring_radius_outer_;\n    float ring_thickness_;\n    float mass_;\n};\n   \nBlackHole gargantua;\nCamera camera;\n\nvoid initScene() {\n    gargantua.position_ = vec3(0.0, 0.0, -8.0 );\n    gargantua.radius_ = 0.1;\n    gargantua.ring_radius_inner_ = gargantua.radius_ + 0.8;\n    gargantua.ring_radius_outer_ = 6.0;\n    gargantua.ring_thickness_ = 0.15;\n    gargantua.mass_ = 1000.0;\n}\n\nvoid initCamera( in vec3 pos, in vec3 target, in vec3 upDir, in float fovV ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y \/ rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nRay genRay( in vec2 pixel )\n{\n    Ray ray;\n    \n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x\/iResolution.y,1.);\n\tvec2 ixy=(pixel\/iResolution.xy - 0.5)*iPlaneSize;\n    \n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\nfloat noise( in vec3 x ) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = ( p.xy + vec2(37.0,17.0)*p.z ) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)\/256.0, 0.0 ).yx;\n\treturn -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat map5( in vec3 p ) {\n\tvec3 q = p;\n\tfloat f;\n    f  = 0.50000*noise( q ); q = q*2.02;\n    f += 0.25000*noise( q ); q = q*2.03;\n    f += 0.12500*noise( q ); q = q*2.01;\n    f += 0.06250*noise( q ); q = q*2.02;\n    f += 0.03125*noise( q );\n\treturn clamp( 1.5 - p.y - 2.0 + 1.75*f, 0.0, 1.0 );\n}\n\n\/\/***********************************************************************\n\/\/ Stars from: nimitz\n\/\/ https:\/\/www.shadertoy.com\/view\/ltfGDs\n\/\/***********************************************************************\nfloat tri(in float x){return abs(fract(x)-.5);}\n\nvec3 hash33(vec3 p){\n\tp  = fract(p * vec3(5.3983, 5.4427, 6.9371));\n    p += dot(p.yzx, p.xyz  + vec3(21.5351, 14.3137, 15.3219));\n\treturn fract(vec3(p.x * p.z * 95.4337, p.x * p.y * 97.597, p.y * p.z * 93.8365));\n}\n\n\/\/smooth and cheap 3d starfield\nvec3 stars(in vec3 p)\n{\n    float fov = radians(50.0);\n    vec3 c = vec3(0.);\n    float res = iResolution.x*.85*fov;\n    \n    \/\/Triangular deformation (used to break sphere intersection pattterns)\n    p.x += (tri(p.z*50.)+tri(p.y*50.))*0.006;\n    p.y += (tri(p.z*50.)+tri(p.x*50.))*0.006;\n    p.z += (tri(p.x*50.)+tri(p.y*50.))*0.006;\n    \n\tfor (float i=0.;i<3.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        float rn = hash33(id).z;\n        float c2 = 1.-smoothstep(-0.2,.4,length(q));\n        c2 *= step(rn,0.005+i*0.014);\n        c += c2*(mix(vec3(1.0,0.75,0.5),vec3(0.85,0.9,1.),rn*30.)*0.5 + 0.5);\n        p *= 1.15;\n    }\n    return c*c*1.5;\n}\n\/\/*****************************************************************************\n\nvec3 getBgColor( vec3 dir ) {\n    float rho, phi, theta;\n    cartesianToSpherical( dir, rho, phi, theta );\n    \n    vec2 uv = vec2( phi\/PI, theta\/TWO_PI );\n    vec3 c0 = texture( iChannel1, uv).xyz*0.3;\n    vec3 c1 = stars(dir);\n    return c0.bgr*0.4 + c1*2.0;\n}\n \nvoid getCloudColorAndDencity(vec3 p, float time, out vec4 color, out float dencity ) {\n    float d2 = dot(p,p);\n        \n    if( sqrt(d2) < gargantua.radius_ ) {\n        dencity = 0.0;\n    } else {\n        float rho, phi, theta;\n        cartesianToSpherical( p, rho, phi, theta );\n\n        \/\/normalize rho\n        rho = ( rho - gargantua.ring_radius_inner_)\/(gargantua.ring_radius_outer_ - gargantua.ring_radius_inner_);\n\n        if( !IN_RANGE( p.y, -gargantua.ring_thickness_, gargantua.ring_thickness_ ) ||\n            !IN_RANGE( rho, 0.0, 1.0 ) ) {\n            dencity = 0.0;\n        } else {\n            float cloudX = sqrt( rho );\n            float cloudY = ((p.y - gargantua.position_.y) + gargantua.ring_thickness_ ) \/ (2.0*gargantua.ring_thickness_);\n            float cloudZ = (theta\/TWO_PI);\n\n            float blending = 1.0; \n\n            blending *= mix(rho*5.0, 1.0 - (rho-0.2)\/(0.8*rho), rho>0.2);\n            blending *= mix(cloudY*2.0, 1.0 -(cloudY-0.5)*2.0, cloudY > 0.5);\n\n            vec3 moving = vec3( time*0.5, 0.0, time*rho*0.1 );\n\n            vec3 localCoord = vec3( cloudX*(rho*rho), -0.02*cloudY, cloudZ );\n\n            dencity = blending*map5( (localCoord + moving)*100.0 );\n            color = 5.0*mix( vec4( 1.0, 0.9, 0.4, rho*dencity ), vec4( 1.0, 0.3, 0.1, rho*dencity ), rho );\n        }\n    }\n}\n\nvec4 Radiance( in Ray ray )\n{\n\tvec4 sum = vec4(0.0);\n\n    float marchingStep = mix( 0.27, 0.3, rnd() );\n    float marchingStart = 2.5;\n    \n    Ray currentRay = Ray ( ray.origin + ray.dir*marchingStart, ray.dir );\n    \n    float transmittance = 1.0;\n    \n    for(int i=0; i<64 && transmittance > 1e-3; i++) {\n        vec3 p = currentRay.origin - gargantua.position_;\n        \n        float dencity;\n        vec4 ringColor;\n        getCloudColorAndDencity(p, iTime*0.1, ringColor, dencity);\n        \n        ringColor *= marchingStep;\n        \n        float tau = dencity * (1.0 - ringColor.w) * marchingStep;\n        transmittance *= exp(-tau);\n\n        sum += transmittance * dencity*ringColor;\n\n#ifdef GRAVITATIONAL_LENSING\n        float G_M1_M2 = 0.50;\n        float d2 = dot(p,p);\n        vec3 gravityVec = normalize(-p)*( G_M1_M2\/d2 );\n        \n        currentRay.dir = normalize( currentRay.dir + marchingStep * gravityVec );\n#endif\n        currentRay.origin = currentRay.origin + currentRay.dir*(marchingStep);\n    }\n    \n    vec3 bgColor = getBgColor( currentRay.dir );\n    sum = vec4( bgColor*transmittance + sum.xyz, 1.0 );\n    \n    return clamp( sum, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    seed = \/*iTime +*\/ iResolution.y * fragCoord.x \/ iResolution.x + fragCoord.y \/ iResolution.y;\n    \n    initScene();\n    \n    vec2 screen_uv = (iMouse.x!=0.0 && iMouse.y!=0.0)?iMouse.xy\/iResolution.xy:vec2( 0.8, 0.4 );\n    \n    float mouseSensitivity = 0.4;\n    vec3 cameraDir = sphericalToCartesian( 1.0, -((HALF_PI - (screen_uv.y)*PI)*mouseSensitivity), (-screen_uv.x*TWO_PI)*mouseSensitivity );\n    \n    initCamera( gargantua.position_ + cameraDir*8.0, gargantua.position_, vec3(0.2, 1.0, 0.0), radians(50.0) );\n    \n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n    for( int i=0; i<SPP; i++ ){\n    \tvec2 screenCoord = fragCoord.xy + vec2( rnd(), rnd() );\n    \tRay ray = genRay( screenCoord );\n        \n        color += Radiance( ray );\n    }\n    \n    fragColor = (1.0\/float(SPP))*color;\n}","name":"Image","description":"","type":"image"}]}]