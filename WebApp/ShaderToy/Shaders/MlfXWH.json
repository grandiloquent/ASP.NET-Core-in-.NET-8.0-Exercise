[{"ver":"0.1","info":{"id":"MlfXWH","date":"1436305756","viewed":4774,"name":"Nightfall","username":"vgs","description":"Everyone needs to do at least one raymarched terrain in shadertoy, right? :)","likes":83,"published":1,"flags":0,"usePreview":1,"tags":["raymarching","moon","night","mountains"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGzn","filepath":"\/media\/a\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","previewfilepath":"\/media\/ap\/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png","type":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"},"published":1}],"outputs":[],"code":"\/\/ Created by Vinicius Graciano Santos - vgs\/2015\n\/\/ Mostly based on iq's presentation at Function 2009.\n\/\/ https:\/\/iquilezles.org\/www\/material\/function2009\/function2009.htm\n\n#define STEPS 256\n#define EPS (2.0\/iResolution.x)\n#define FAR 6.0\n#define PI 3.14159265359\n\n#define iGT (iTime+10.0)\n\nvec3 noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    \/\/ Quintic because everyone else is using the cubic! :D\n    vec2 df = 30.0*f*f*(f*(f-2.0)+1.0);\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    float a = texture(iChannel0, (i+vec2(0.5, 0.5))\/256., -100.0).r;\n    float b = texture(iChannel0, (i+vec2(1.5, 0.5))\/256., -100.0).r;\n    float c = texture(iChannel0, (i+vec2(0.5, 1.5))\/256., -100.0).r;\n    float d = texture(iChannel0, (i+vec2(1.5, 1.5))\/256., -100.0).r;\n    \n    float k = a-b-c+d;\n    float n = mix(mix(a, b, f.x), mix(c, d, f.x), f.y);\n    \n    return vec3(n, vec2(b-a+k*f.y, c-a+k*f.x)*df);\n}\n\nmat2 m = mat2(0.8,-0.6,0.6,0.8);\nfloat fbmSimple(vec2 p) {\n    float f = 0.0;\n    f += 0.5*noise(p).x; p = 2.0*m*p;\n    f += 0.25*noise(p).x; p = 2.0*m*p;\n    f += 0.125*noise(p).x; p = 2.0*m*p;\n    f += 0.0625*noise(p).x;\n    return f\/0.9375;\n}\n\nfloat fbmL(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 0.0, w = 0.5;\n    \n    for (int i = 0; i < 2; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x\/ (1.0 + dot(df, df)));\n        w *= 0.5; p = 2.*m*p;\n    }\n    return f;\n}\n\nfloat fbmM(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 0.0, w = 0.5;\n    \n    for (int i = 0; i < 4; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x\/ (1.0 + dot(df, df)));\n        w *= 0.5; p = 2.*m*p;\n    }\n    return f;\n}\n\nfloat fbmH(vec2 p) {\n    vec2 df = vec2(0.0);\n    float f = 0.0, w = 0.5;\n    \n    for (int i = 0; i < 10; ++i) {\n        vec3 n = noise(p);\n        df += n.yz;\n        f += abs(w * n.x\/ (1.0 + dot(df, df)));\n        w *= 0.5; p = 2.*m*p;\n    }\n    return f;\n}\n\nfloat map(vec3 p) {\n    return p.y - fbmM(p.xz);\n}\n\nfloat mapL(vec3 p) {\n    return p.y - fbmL(p.xz);\n}\n\nfloat mapH(vec3 p) {\n    return p.y - fbmH(p.xz);\n}\n\nvec3 normal(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(mapH(p+q.yxx) - mapH(p-q.yxx),\n                \t\t  mapH(p+q.xyx) - mapH(p-q.xyx),\n                \t\t  mapH(p+q.xxy) - mapH(p-q.xxy)));\n}\n\nvec3 normalL(vec3 p) {\n    vec2 q = vec2(0., EPS);\n    return normalize(vec3(mapL(p+q.yxx) - mapL(p-q.yxx),\n                \t\t  mapL(p+q.xyx) - mapL(p-q.xyx),\n                \t\t  mapL(p+q.xxy) - mapL(p-q.xxy)));\n}\n\nvec3 skyCol = 2.5*pow(vec3(40., 56., 84.)\/255., vec3(2.2));\nvec3 moonCol = pow(vec3(168., 195., 224.)\/255., vec3(2.2));\n\nvec3 fogColor(vec3 sundir, vec3 dir) {\n    vec3 col = skyCol + moonCol*pow(max(dot(sundir, dir), 0.0), 16.0)*max(0.0, -dir.z);\n    return col \/ (col + 1.0);\n}\n\nvec3 fullSky(vec3 sundir, vec3 dir) {\n    vec3 stars = vec3(smoothstep(0.8, 0.95, fbmSimple(100.0*dir.xy\/(dir.z+EPS))));\n    \n    vec3 clouds = vec3(0.0);\n    float s = 0.25;\n    for (int i = 0; i < 3; ++i) {\n    \tclouds += fbmSimple(dir.xz\/(dir.y+EPS)-s*iGT);\n        s *= 1.35;\n    }\n    \n    vec3 col = skyCol + 0.15*clouds*max(0.0, dir.y);\n    col += 2.0*stars*max(0.0, dir.y);\n    \n    col += max(0.0, -dir.z)*moonCol*pow(max(dot(sundir, dir), 0.0), 16.0);\n    vec2 moonPos = dir.xy\/dir.z - sundir.xy\/sundir.z;\n    col = mix(col, vec3(1.65), max(0.0, -dir.z)*fbmSimple(8.5*moonPos)*smoothstep(0.37, 0.35, length(moonPos)));\n    \n    return col \/ (col + 1.0);\n}\n\nvec3 material(vec3 p, vec3 n) {\n    vec3 brown = pow(vec3(185., 122., 87.)\/255., vec3(2.2));\n    return mix(vec3(1.0), brown, smoothstep(0.6*n.y, 1.0*n.y, fbmH(p.xz)));\n}\n\nvec3 shade(vec3 ro, vec3 rd, float t) {\n    vec3 l = normalize(vec3(1.0, 0.0, -1.0));\n      \n    vec3 col = fullSky(l, rd);\n    \n    if (t > 0.0) {\n        vec3 p = ro +t*rd;\n        vec3 n = normal(p);\n        vec3 h = normalize(l - rd);\n        vec3 r = reflect(rd, h);\n    \t        \n        float shin = 5.0, r0 = 0.25;\n        float fresnel = (r0 + (1.0 - r0)*pow((1.0-dot(-rd, h)), 5.0));\n        vec3 spec_light = fogColor(l, r);\n        vec3 spec_brdf = vec3(1.0)*fresnel*(shin + 8.0)\/(8.0*PI)*pow(max(dot(n, h), 0.0), shin);\n        \n        vec3 tex = material(p, n);\n        vec3 diff_light = pow(vec3(168., 195., 224.)\/255., vec3(2.2));\n        vec3 diff_brdf = tex*(1.0-fresnel)\/PI;\n        \n        float shadow = clamp(5.0*dot(normalL(p), l), 0.0, 1.0);\n            \n        float fog = 1.0 - exp(-0.25*t);\n        vec3 lcol = (diff_brdf*diff_light + spec_brdf*spec_light)*shadow*max(dot(n, l), 0.0);\n    \tcol = mix(0.97*lcol + 0.03*tex*n.y, fogColor(l, rd), fog);\n    }\n    return clamp(col \/ (col + 1.0), 0.0, 1.0);\n}\n\nfloat raymarch(vec3 ro, vec3 rd) {\n    float d = 0., t = 0.0;\n    for (int i = 0; i < STEPS; ++i) {\n        d = map(ro + t*rd);\n        if (d < EPS*t || t > FAR)\n            break;\n        t += max(0.35*d, 2.*EPS*t);\n    }\n   \n    return d < EPS*t ? t : -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (-iResolution.xy + 2.0*fragCoord.xy) \/ iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, -0.2*iGT); ro.y = 0.15 + 1.2*fbmL(ro.xz);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    \n    float t = raymarch(ro, rd);\n    vec3 col = pow(shade(ro, rd, t), vec3(1.0\/2.2));\n    \n    col = smoothstep(0.0, 1.0, col);\n    col *= 1.2;\n    \n\tfragColor = vec4(col, 1.);\n}","name":"","description":"","type":"image"}]}]