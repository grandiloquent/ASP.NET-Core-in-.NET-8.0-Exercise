[{"ver":"0.1","info":{"id":"cdj3DW","date":"1667608685","viewed":1670,"name":"Starfield (2022)","username":"jurnip","description":"Starfield with nebulae based on the kaliset fractal\nUse the mouse to pan\n\nBased on \"Simplicity Galaxy\" by CBS: https:\/\/www.shadertoy.com\/view\/MslGWN","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["fractal","star","stars","nebula","starfield"],"hasliked":0,"parentid":"MslGWN","parentname":"Simplicity Galaxy"},"renderpass":[{"inputs":[],"outputs":[],"code":"\/\/ By Jared Berghold 2022 (https:\/\/www.jaredberghold.com\/)\n\/\/ Based on the \"Simplicity Galaxy\" shader by CBS (https:\/\/www.shadertoy.com\/view\/MslGWN) \n\/\/ The nebula effect is based on the kaliset fractal (https:\/\/softologyblog.wordpress.com\/2011\/05\/04\/kalisets-and-hybrid-ducks\/)\n\nconst int MAX_ITER = 18;\n\nfloat field(vec3 p, float s, int iter)\n{\n\tfloat accum = s \/ 4.0;\n\tfloat prev = 0.0;\n\tfloat tw = 0.0;\n\tfor (int i = 0; i < MAX_ITER; ++i) \n  \t{\n\t\tif (i >= iter) \/\/ drop from the loop if the number of iterations has been completed - workaround for GLSL loop index limitation\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tfloat mag = dot(p, p);\n\t\tp = abs(p) \/ mag + vec3(-0.5, -0.4, -1.487);\n\t\tfloat w = exp(-float(i) \/ 5.0);\n\t\taccum += w * exp(-9.025 * pow(abs(mag - prev), 2.2));\n\t\ttw += w;\n\t\tprev = mag;\n\t}\n\treturn max(0.0, 5.2 * accum \/ tw - 0.65);\n}\n\nvec3 nrand3(vec2 co)\n{\n\tvec3 a = fract(cos(co.x*8.3e-3 + co.y) * vec3(1.3e5, 4.7e5, 2.9e5));\n\tvec3 b = fract(sin(co.x*0.3e-3 + co.y) * vec3(8.1e5, 1.0e5, 0.1e5));\n\tvec3 c = mix(a, b, 0.5);\n\treturn c;\n}\n\nvec4 starLayer(vec2 p, float time)\n{\n\tvec2 seed = 1.9 * p.xy;\n\tseed = floor(seed * max(iResolution.x, 600.0) \/ 1.5);\n\tvec3 rnd = nrand3(seed);\n\tvec4 col = vec4(pow(rnd.y, 17.0));\n\tfloat mul = 10.0 * rnd.x;\n\tcol.xyz *= sin(time * mul + mul) * 0.25 + 1.0;\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime \/ (iResolution.x \/ 1000.0);\n\t\n    \/\/ first layer of the kaliset fractal\n\tvec2 uv = 2.0 * fragCoord \/ iResolution.xy - 1.0;\n  \tvec2 uvs = uv * iResolution.xy \/ max(iResolution.x, iResolution.y);\n\tvec3 p = vec3(uvs \/ 2.5, 0.0) + vec3(0.8, -1.3, 0.0);\n\tp += 0.45 * vec3(sin(time \/ 32.0), sin(time \/ 24.0), sin(time \/ 64.0));\n\t\n\t\/\/ adjust first layer position based on mouse movement\n\tp.x += mix(-0.02, 0.02, (iMouse.x \/ iResolution.x));\n\tp.y += mix(-0.02, 0.02, (iMouse.y \/ iResolution.y));\n\t\n\tfloat freqs[4];\n\tfreqs[0] = 0.45;\n\tfreqs[1] = 0.4;\n\tfreqs[2] = 0.15;\n\tfreqs[3] = 0.9;\n\n\tfloat t = field(p, freqs[2], 13);\n\tfloat v = (1.0 - exp((abs(uv.x) - 1.0) * 6.0)) * (1.0 - exp((abs(uv.y) - 1.0) * 6.0));\n\t\n    \/\/ second layer of the kaliset fractal\n\tvec3 p2 = vec3(uvs \/ (4.0 + sin(time * 0.11) * 0.2 + 0.2 + sin(time * 0.15) * 0.3 + 0.4), 4.0) + vec3(2.0, -1.3, -1.0);\n\tp2 += 0.16 * vec3(sin(time \/ 32.0), sin(time \/ 24.0), sin(time \/ 64.0));\n\t\n\t\/\/ adjust second layer position based on mouse movement\n\tp2.x += mix(-0.01, 0.01, (iMouse.x \/ iResolution.x));\n\tp2.y += mix(-0.01, 0.01, (iMouse.y \/ iResolution.y));\n\tfloat t2 = field(p2, freqs[3], 18);\n\tvec4 c2 = mix(0.5, 0.2, v) * vec4(5.5 * t2 * t2 * t2, 2.1 * t2 * t2, 2.2 * t2 * freqs[0], t2);\n\t\n\t\/\/ add stars (source: https:\/\/glslsandbox.com\/e#6904.0)\n\tvec4 starColour = vec4(0.0);\n\tstarColour += starLayer(p.xy, time); \/\/ add first layer of stars\n\tstarColour += starLayer(p2.xy, time); \/\/ add second layer of stars\n\n\tconst float brightness = 1.0;\n\tvec4 colour = mix(freqs[3] - 0.3, 1.0, v) * vec4(1.5 * freqs[2] * t * t * t, 1.2 * freqs[1] * t * t, freqs[3] * t, 1.0) + c2 + starColour;\n\tfragColor = vec4(brightness * colour.xyz, 1.0);\n}\n","name":"Image","description":"","type":"image"}]}]