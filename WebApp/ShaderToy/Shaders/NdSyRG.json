[{"ver":"0.1","info":{"id":"NdSyRG","date":"1643654475","viewed":95,"name":"Neon atom","username":"tintingai","description":"3d representation of a neon atom (symbolic representation)","likes":3,"published":1,"flags":0,"usePreview":0,"tags":["atom"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/* src:\nhttps:\/\/inspirnathan.com\/posts\/52-shadertoy-tutorial-part-6\nDodecahedron vertices: https:\/\/www.wolframalpha.com\/input\/?i=PolyhedronData%5B%22Dodecahedron%22%2C+%22VertexCoordinates%22%5D\ncourses of Maxime MARIA, my image synthesis professor, teaching in the Limoges University\n*\/\nconst float PI = 3.141592;\n\nconst float RAYMIN = 0.0;\nconst float RAYMAX = 20.0;\nconst int RAYSTEP = 70;\nconst float PREC_RAY = 0.001; \/\/precision of the ray\n\nconst vec3 BACK_COLOR = vec3(0.6);\nconst vec3 LIGHT_POS = vec3(5., 2., 4.);\nconst float GI_SIM = 0.5; \/\/global illumination simulation (between 0. and 1.)\n\nconst vec3 CENTER_ATOM = vec3(0., 0., -6.);\nconst vec3 COLOR_NEUTRON = vec3(0., 0., 0.7);\nconst vec3 COLOR_PROTON = vec3(0.7, 0., 0.);\nconst vec3 COLOR_ELECTRON = vec3(0., 0.7, 0.7);\n\n\/*return mat4 translation according to the vec3 vt*\/\nmat4 getMatT(vec3 vt){\n    return mat4( vec4(1., 0., 0., 0.),\n                 vec4(0., 1., 0., 0.),\n                 vec4(0., 0., 1., 0.),\n                 vec4(vt.x, vt.y, vt.z, 1.));\n}\n\n\/*return mat4 scaling (homothetic) according to the vec3 vs*\/\nmat4 getMatS(vec3 vs){\n    return mat4( vec4(vs.x, 0.,    0.,   0.),\n                 vec4(0.,   vs.y,  0.,   0.),\n                 vec4(0.,   0.,    vs.z, 0.),\n                 vec4(0.,   0.,    0.,   1.));\n}\n\nmat4 getMatRotX(float a){\n    return mat4( vec4(1., 0.,      0.,       0.),\n                 vec4(0., cos(a),  sin(a),   0.),\n                 vec4(0., -sin(a), cos(a),   0.),\n                 vec4(0., 0.,      0.,       1.));\n}\n\nmat4 getMatRotY(float a){\n    return mat4( vec4(cos(a),  0., sin(a), 0.),\n                 vec4(0.,      1., 0.,     0.),\n                 vec4(-sin(a), 0., cos(a), 0.),\n                 vec4(0.,      0., 0.,     1.));\n}\n\nmat4 getMatRotZ(float a){\n    return mat4( vec4(cos(a), sin(a),  0., 0.),\n                 vec4(-sin(a), cos(a), 0., 0.),\n                 vec4(0.,      0.,     1., 0.),\n                 vec4(0.,      0.,     0., 1.));\n}\n\n\nvec4 dist_sphere(vec3 p, vec3 center, float r, vec3 color){\n    return vec4(length(p - center) - r, color);\n}\n\nvec4 sdScene(vec3 p){\n    \/\/proton and neutron (core)\n    float gap = 0.35;\n    float size = 0.3;\n    \n    \/\/center\n    vec3 cp0 = (getMatT(CENTER_ATOM) * vec4(0., 0., 0., 1.)).xyz;\n    \n    \/\/neutron\n    float sa = PI\/2.; \/\/start angle\n    mat4 Mtransform = getMatRotY(-iTime) * getMatRotX(iTime\/2.) * getMatS(vec3(gap));\n    \n    \/*creation of the center of the neutron and proton following a regular dodecahedron shape (see src below)*\/\n    vec3 cp1  = (Mtransform * vec4( -sqrt(0.2*(5.+2.*sqrt(5.))),        0.,                  0.5*sqrt(0.1*(5.-sqrt(5.))),        1.)).xyz + CENTER_ATOM;\n    vec3 cp2  = (Mtransform * vec4( sqrt(0.2*(5.+2.*sqrt(5.))),         0.,                  -0.5*sqrt(0.1*(5.-sqrt(5.))),       1.)).xyz + CENTER_ATOM;\n    vec3 cp3  = (Mtransform * vec4( -0.5*sqrt(0.1*(5.+sqrt(5.))),       0.25*(-3.-sqrt(5.)), 0.5*sqrt(0.1*(5.-sqrt(5.))),        1.)).xyz + CENTER_ATOM;\n    vec3 cp4  = (Mtransform * vec4( -0.5*sqrt(0.1*(5.+sqrt(5.))),       0.25*(3.+sqrt(5.)),  0.5*sqrt(0.1*(5.-sqrt(5.))),        1.)).xyz + CENTER_ATOM;\n    vec3 cp5  = (Mtransform * vec4( sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  0.25*(-1.-sqrt(5.)), 0.5*sqrt(0.1*(5.-sqrt(5.))),        1.)).xyz + CENTER_ATOM;\n    vec3 cp6  = (Mtransform * vec4( sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  0.25*(1.+sqrt(5.)),  0.5*sqrt(0.1*(5.-sqrt(5.))),        1.)).xyz + CENTER_ATOM;\n    vec3 cp7  = (Mtransform * vec4( -0.5*sqrt(0.1*(5.-sqrt(5.))),       0.25*(-1.-sqrt(5.)), sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  1.)).xyz + CENTER_ATOM;\n    vec3 cp8  = (Mtransform * vec4( -0.5*sqrt(0.1*(5.-sqrt(5.))),       0.25*(1.+sqrt(5.)),  sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  1.)).xyz + CENTER_ATOM;\n    vec3 cp9  = (Mtransform * vec4( -sqrt(0.25+(1.\/(2.*sqrt(5.)))),     -0.5,                -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 1.)).xyz + CENTER_ATOM;\n    vec3 cp10 = (Mtransform * vec4( -sqrt(0.25+(1.\/(2.*sqrt(5.)))),     0.5,                 -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 1.)).xyz + CENTER_ATOM;\n    vec3 cp11 = (Mtransform * vec4( sqrt(0.25+(1.\/(2.*sqrt(5.)))),      -0.5,                sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  1.)).xyz + CENTER_ATOM;\n    vec3 cp12 = (Mtransform * vec4( sqrt(0.25+(1.\/(2.*sqrt(5.)))),      0.5,                 sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  1.)).xyz + CENTER_ATOM;\n    vec3 cp13 = (Mtransform * vec4( sqrt(0.1*(5.+sqrt(5.))),            0.,                  -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 1.)).xyz + CENTER_ATOM;\n    vec3 cp14 = (Mtransform * vec4( -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 0.25*(-1.-sqrt(5.)), -0.5*sqrt(0.1*(5.-sqrt(5.))),       1.)).xyz + CENTER_ATOM;\n    vec3 cp15 = (Mtransform * vec4( -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 0.25*(1.+sqrt(5.)),  -0.5*sqrt(0.1*(5.-sqrt(5.))),       1.)).xyz + CENTER_ATOM;\n    vec3 cp16 = (Mtransform * vec4( -sqrt(0.1*(5.+sqrt(5.))),           0.,                  sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))),  1.)).xyz + CENTER_ATOM;\n    vec3 cp17 = (Mtransform * vec4( 0.5*sqrt(0.1*(5.-sqrt(5.))),        0.25*(-1.-sqrt(5.)), -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 1.)).xyz + CENTER_ATOM;\n    vec3 cp18 = (Mtransform * vec4( 0.5*sqrt(0.1*(5.-sqrt(5.))),        0.25*(1.+sqrt(5.)),  -sqrt((5.\/8.)+(11.\/(8.*sqrt(5.)))), 1.)).xyz + CENTER_ATOM;\n    vec3 cp19 = (Mtransform * vec4( 0.5*sqrt(0.1*(5.+sqrt(5.))),        0.25*(-3.-sqrt(5.)), -0.5*sqrt(0.1*(5.-sqrt(5.))),       1.)).xyz + CENTER_ATOM;\n    vec3 cp20 = (Mtransform * vec4( 0.5*sqrt(0.1*(5.+sqrt(5.))),        0.25*(3.+sqrt(5.)),  -0.5*sqrt(0.1*(5.-sqrt(5.))),       1.)).xyz + CENTER_ATOM;\n    \n    \n    \/\/compute intersection of neutron\n    \/\/vec4 p0 = dist_sphere(p, cp0, size, color_neutron);\n    \/\/vec4 p0 = dist_sphere(p, cp0, 0.05, vec3(1., 1., 0.));\n    vec4 p1 = dist_sphere(p, cp1, size, COLOR_PROTON);\n    vec4 p2 = dist_sphere(p, cp2, size, COLOR_PROTON);\n    vec4 p3 = dist_sphere(p, cp3, size, COLOR_PROTON);\n    vec4 p4 = dist_sphere(p, cp4, size, COLOR_PROTON);\n    vec4 p5 = dist_sphere(p, cp5, size, COLOR_PROTON);\n    vec4 p6 = dist_sphere(p, cp6, size, COLOR_PROTON);\n    vec4 p7 = dist_sphere(p, cp7, size, COLOR_PROTON);\n    vec4 p8 = dist_sphere(p, cp8, size, COLOR_PROTON);\n    vec4 p9 = dist_sphere(p, cp9, size, COLOR_PROTON);\n    vec4 p10 = dist_sphere(p, cp10, size, COLOR_PROTON);\n    vec4 p11 = dist_sphere(p, cp11, size, COLOR_NEUTRON);\n    vec4 p12 = dist_sphere(p, cp12, size, COLOR_NEUTRON);\n    vec4 p13 = dist_sphere(p, cp13, size, COLOR_NEUTRON);\n    vec4 p14 = dist_sphere(p, cp14, size, COLOR_NEUTRON);\n    vec4 p15 = dist_sphere(p, cp15, size, COLOR_NEUTRON);\n    vec4 p16 = dist_sphere(p, cp16, size, COLOR_NEUTRON);\n    vec4 p17 = dist_sphere(p, cp17, size, COLOR_NEUTRON);\n    vec4 p18 = dist_sphere(p, cp18, size, COLOR_NEUTRON);\n    vec4 p19 = dist_sphere(p, cp19, size, COLOR_NEUTRON);\n    vec4 p20 = dist_sphere(p, cp20, size, COLOR_NEUTRON);\n    \n    \n    \/\/electrons\n    float e_s1 = 8.; \/\/electron speed layer 1\n    float e_s2 = 4.; \/\/electron speed layer 2\n    float e_rl1 = 1.5; \/\/electron radius to the center of layer 1\n    float e_rl2 = 4.; \/\/electron radius to the center of layer 2\n    mat4 Mtransform_elayer1 = getMatRotY(iTime) * getMatS(vec3(e_rl1));\n    mat4 Mtransform_elayer2 = getMatRotY(iTime) * getMatS(vec3(e_rl2));\n    \n    \/\/layer 2\n    float o1 = PI\/8.; \/\/orientation to the Y axis\n    float shift1 = 0.;\n    vec3 ce1 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+shift1),    sin(iTime*e_s2+shift1)*cos(o1),    sin(iTime*e_s2+shift1)*sin(o1), 1.)).xyz    + CENTER_ATOM;\n    vec3 ce2 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+PI+shift1), sin(iTime*e_s2+PI+shift1)*cos(o1), sin(iTime*e_s2+PI+shift1)*sin(o1), 1.)).xyz + CENTER_ATOM;\n    \n    float o2 = o1 + PI\/4.;\n    float shift2 = o2;\n    vec3 ce3 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+shift2),    sin(iTime*e_s2+shift2)*cos(o2),    sin(iTime*e_s2+shift2)*sin(o2), 1.)).xyz    + CENTER_ATOM;\n    vec3 ce4 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+PI+shift2), sin(iTime*e_s2+PI+shift2)*cos(o2), sin(iTime*e_s2+PI+shift2)*sin(o2), 1.)).xyz + CENTER_ATOM;\n    \n    float o3 = o2 + PI\/4.;\n    float shift3 = o3;\n    vec3 ce5 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+shift3),    sin(iTime*e_s2+shift3)*cos(o3),    sin(iTime*e_s2+shift3)*sin(o3), 1.)).xyz    + CENTER_ATOM;\n    vec3 ce6 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+PI+shift3), sin(iTime*e_s2+PI+shift3)*cos(o3), sin(iTime*e_s2+PI+shift3)*sin(o3), 1.)).xyz + CENTER_ATOM;\n    \n    float o4 = o3 + PI\/4.;\n    float shift4 = o4;\n    vec3 ce7 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+shift4),    sin(iTime*e_s2+shift4)*cos(o4),    sin(iTime*e_s2+shift4)*sin(o4), 1.)).xyz    + CENTER_ATOM;\n    vec3 ce8 = (Mtransform_elayer2 * vec4(cos(iTime*e_s2+PI+shift4), sin(iTime*e_s2+PI+shift4)*cos(o4), sin(iTime*e_s2+PI+shift4)*sin(o4), 1.)).xyz + CENTER_ATOM;\n    \n    \/\/layer 1\n    float o5 = PI\/6.;\n    float shift5 = 0.;\n    vec3 ce9 = (Mtransform_elayer1 * vec4(cos(iTime*e_s1+shift5),    sin(iTime*e_s1+shift5)*cos(o5),    sin(iTime*e_s1+shift5)*sin(o5), 1.)).xyz    + CENTER_ATOM;\n    vec3 ce10 = (Mtransform_elayer1 * vec4(cos(iTime*e_s1+PI+shift5),sin(iTime*e_s1+PI+shift5)*cos(o5), sin(iTime*e_s1+PI+shift5)*sin(o5), 1.)).xyz + CENTER_ATOM;\n\n\n    vec4 e1 = dist_sphere(p, ce1, 0.1, COLOR_ELECTRON);\n    vec4 e2 = dist_sphere(p, ce2, 0.1, COLOR_ELECTRON);\n    vec4 e3 = dist_sphere(p, ce3, 0.1, COLOR_ELECTRON);\n    vec4 e4 = dist_sphere(p, ce4, 0.1, COLOR_ELECTRON);\n    vec4 e5 = dist_sphere(p, ce5, 0.1, COLOR_ELECTRON);\n    vec4 e6 = dist_sphere(p, ce6, 0.1, COLOR_ELECTRON);\n    vec4 e7 = dist_sphere(p, ce7, 0.1, COLOR_ELECTRON);\n    vec4 e8 = dist_sphere(p, ce8, 0.1, COLOR_ELECTRON);\n    vec4 e9 = dist_sphere(p, ce9, 0.1, COLOR_ELECTRON);\n    vec4 e10 = dist_sphere(p, ce10, 0.1, COLOR_ELECTRON);\n    \n    \n    \/*keep only le nearest element*\/\n    vec4 dc_final;\n    dc_final = p1.x < p2.x ? p1 : p2;\n    \/\/dc_final = p0.x < dc_final.x ? p0 : dc_final;\n    dc_final = p3.x < dc_final.x ? p3 : dc_final;\n    dc_final = p4.x < dc_final.x ? p4 : dc_final;\n    dc_final = p5.x < dc_final.x ? p5 : dc_final;\n    dc_final = p6.x < dc_final.x ? p6 : dc_final;\n    dc_final = p7.x < dc_final.x ? p7 : dc_final;\n    dc_final = p8.x < dc_final.x ? p8 : dc_final;\n    dc_final = p9.x < dc_final.x ? p9 : dc_final;\n    dc_final = p10.x < dc_final.x ? p10 : dc_final;\n    dc_final = p11.x < dc_final.x ? p11 : dc_final;\n    dc_final = p12.x < dc_final.x ? p12 : dc_final;\n    dc_final = p13.x < dc_final.x ? p13 : dc_final;\n    dc_final = p14.x < dc_final.x ? p14 : dc_final;\n    dc_final = p15.x < dc_final.x ? p15 : dc_final;\n    dc_final = p16.x < dc_final.x ? p16 : dc_final;\n    dc_final = p17.x < dc_final.x ? p17 : dc_final;\n    dc_final = p18.x < dc_final.x ? p18 : dc_final;\n    dc_final = p19.x < dc_final.x ? p19 : dc_final;\n    dc_final = p20.x < dc_final.x ? p20 : dc_final;\n    \n    dc_final = e1.x < dc_final.x ? e1 : dc_final;\n    dc_final = e2.x < dc_final.x ? e2 : dc_final;\n    dc_final = e3.x < dc_final.x ? e3 : dc_final;\n    dc_final = e4.x < dc_final.x ? e4 : dc_final;\n    dc_final = e5.x < dc_final.x ? e5 : dc_final;\n    dc_final = e6.x < dc_final.x ? e6 : dc_final;\n    dc_final = e7.x < dc_final.x ? e7 : dc_final;\n    dc_final = e8.x < dc_final.x ? e8 : dc_final;\n    dc_final = e9.x < dc_final.x ? e9 : dc_final;\n    dc_final = e10.x < dc_final.x ? e10 : dc_final;\n    \n    \n    return dc_final;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0005; \/\/ epsilon\n    return normalize(\n      e.xyy * sdScene(p + e.xyy).x +\n      e.yyx * sdScene(p + e.yyx).x +\n      e.yxy * sdScene(p + e.yxy).x +\n      e.xxx * sdScene(p + e.xxx).x);\n}\n\n\n\/*  ro: ray origin \n    rd: ray direction (normalized)*\/\nvec4 ray(vec3 ro, vec3 rd){\n    vec3 p;\n    float depth = RAYMIN;\n    \n    for(int i=0; i<RAYSTEP; i++){\n        p = ro + depth*rd;\n        vec4 vtmp = sdScene(p);\n        float dist = vtmp.x;\n        depth += dist;\n        if(dist < PREC_RAY || depth > RAYMAX) return vec4(depth, vtmp.yzw);\n    }\n    return vec4(depth, BACK_COLOR);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy - 0.5;\n    uv.x *= iResolution.x\/iResolution.y;\n    \n    vec3 ro = vec3(0., 0., 3.);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    vec4 vtmp = ray(ro, rd);\n    float dist = vtmp.x;\n\n    vec3 color_final = BACK_COLOR;\n    if(dist < RAYMAX){\n        vec3 difuse_color = vtmp.yzw;\n        vec3 pi = ro + dist*rd;\n        vec3 pi_normal = calcNormal(pi);\n        \n        vec3 lightdir = normalize(LIGHT_POS - pi);\n        \n        vec3 ambient_color = difuse_color*GI_SIM;\n        vec3 difuse_lighting = clamp(dot(pi_normal, lightdir), 0., 1.) * difuse_color;\n        \n        float specular_dot = clamp(dot(reflect(lightdir, pi_normal), rd), 0., 1.);\n        vec3 specular_lighting = pow(specular_dot, 10.) * vec3(1.);\n        \n        color_final = ambient_color + difuse_lighting + specular_lighting;\n    }\n    \n    fragColor = vec4(color_final, 1.);\n}\n","name":"Image","description":"","type":"image"}]}]