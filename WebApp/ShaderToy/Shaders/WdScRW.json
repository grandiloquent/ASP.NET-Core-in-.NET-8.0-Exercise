[{"ver":"0.1","info":{"id":"WdScRW","date":"1586169751","viewed":2116,"name":"Habitable Planet","username":"Kali","description":"I challenged myself to make a planet using only the kaliset fractal. ","likes":49,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","fractal","planet","kaliset"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"const float det = .001;\nvec3 ldir = vec3(2., .5, -.5);\nfloat objid, objcol, coast;\nconst vec3 water_color = vec3(0., .4, .8);\nconst vec3 land_color1 = vec3(.6, 1., .5);\nconst vec3 land_color2 = vec3(.6, .2, .0);\nconst vec3 atmo_color = vec3(.4, .65, .9);\nconst vec3 cloud_color = vec3(1.3);\n\n\nmat2 rot(float a) {\n\tfloat s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat kset(int it, vec3 p, vec3 q, float sc, float c) {\n    p.xz *= rot(iTime * .2);\n    p += q;\n    p *= sc;\n    float l = 0., l2;\n    for (int i = 0; i < it; i++) {\n    \tp = abs(p) \/ dot(p, p) - c;\n\t\tl += exp(-1. * abs(length(p) - l2));\n\t    l2 = length(p);\n    }\n    return l * .08;    \n}\n\nfloat clouds(vec3 p2, vec3 dir) {\n\t\tp2 -= .1 * dir;\n    \tp2.y *= 3.;\n    \tfloat cl1 = 0., cl2 = 0.;\n        for (int i = 0; i < 15; i++) {\n\t\t\tp2 -= .05 * dir;\n            cl1 += kset(20, p2, vec3(1.7, 3., .54), .3, .95);\n            cl2 += kset(18, p2, vec3(1.2, 1.7, 1.4), .2, .85);\n        }    \n        cl1 = pow(cl1 * .045, 10.);\n        cl2 = pow(cl2 * .055, 15.);\n\t\treturn cl1 - cl2;\n}\n\nfloat de(vec3 p) {\n    float surf1 = kset(6, p, vec3(.523, 1.547, .754), .2, .9);\n    float surf2 = kset(8, p, vec3(.723, 1.247, .354), .2, .8) * .7;\n    float surf3 = kset(10, p, vec3(1.723, .347, .754), .3, .6) * .5;\n    objcol = pow(surf1 + surf2 + surf3, 5.);\n\tfloat land = length(p) - 3. - surf1 * .8 - surf2 * .1;\n    float water = length(p) - 3.31;\n    float d = min(land, water);\n\tobjid = step(water, d) + step(land, d) * 2.;\n\tcoast = max(0., .03 - abs(land - water)) \/ .03;\n    return d * .8;\n}\n\nfloat de_clouds(vec3 p, vec3 dir) {\n    return length(p)-clouds(p, dir)*.05;\n}\n\n\nvec3 normal(vec3 p) {\n    vec3 eps = vec3(0., det, 0.);\n\treturn normalize(vec3(de(p + eps.yxx), de(p + eps.xyx), de(p + eps.xxy)) - de(p));\n}\n\nvec3 normal_clouds(vec3 p, vec3 dir) {\n    vec3 eps = vec3(0., .05, 0.);\n\tvec3 n = normalize(vec3(de_clouds(p + eps.yxx, dir), de_clouds(p + eps.xyx, dir), de_clouds(p + eps.xxy, dir)) - de_clouds(p, dir));\n\treturn n;\n}\n\nfloat shadow(vec3 desde) {\n    ldir=normalize(ldir);\n    float td=.1,sh=1.,d;\n    for (int i=0; i<10; i++) {\n\t\tvec3 p=desde+ldir*td;\n        d=de(p);\n        td+=d;\n\t\tsh=min(sh,20.*d\/td);\n\t\tif (sh<.001) break;\n    }\n    return clamp(sh,0.,1.);\n}\n\nvec3 color(float id, vec3 p) {\n\tvec3 c = vec3(0.);\n    float k = smoothstep(.0, .7, kset(9, p, vec3(.63, .7, .54), .1, .8));\n    vec3 land = mix(land_color1, land_color2, k); \n    vec3 water = water_color * (objcol + .5) + coast * .7; \n\tfloat polar = pow(min(1.,abs(p.y * .4 + k * .3 - .1)),10.);\n    land = mix(land, vec3(1.), polar);\n\twater = mix(water, vec3(1.5), polar);\n    c += water * step(abs(id - 1.), .1);\n    c += land * step(abs(id - 2.), .1) * objcol * 3.;\n    return c;\n}\n\n\nvec3 shade(vec3 p, vec3 dir, vec3 n, vec3 col, float id) {\n\tldir = normalize(ldir);\n    float amb = .05;\n    float sh = shadow(p);\n    float dif = max(0., dot(ldir, n)) * .7 * sh;\n    vec3 ref = reflect(ldir, n) * sh;\n    float spe = pow(max(0., dot(ref, dir)), 10.) * .5 * (.3+step(abs(id - 1.), .1));\n    return (amb + dif) * col + spe;\n}\n\nvec3 march(vec3 from, vec3 dir) {\n\tfloat td, d, g = 0.;\n    vec3 c = vec3(0.), p;\n    for (int i = 0; i < 60; i++) {\n    \tp = from + dir * td;\n        d = de(p);\n        td += d;\n        if (td > 50. || d < det) break;\n\t\tg += smoothstep(-4.,1.,p.x);\n    }\n    if (d < det) {\n    \tp -= det * dir * 2.;\n        vec3 col = color(objid, p);\n        vec3 n = normal(p);\n        c = shade(p, dir, n, col, objid);\n        \/\/cl1 = clamp(cl1, 0., 1.);\n        float cl1 = clouds(p, dir);\n\t\tvec3 nc = normal_clouds(p, dir);\n        c = mix(c, .1 + cloud_color * max(0., dot(normalize(ldir), nc)), clamp(cl1,0.,1.));\n    }\n    else\n    {\n        vec2 pp = dir.xy + vec2(.434, .746);\n        float m1 = 100., m2 = m1;\n        for (int i=0; i < 6; i++) {\n        \tpp = abs(pp) \/ dot(pp, pp) - .9;\n        \tm1 = min(m1, length(pp * vec2(4.,1.)));\n        \tm2 = min(m2, length(pp * vec2(1.,4.)));\n        }\n\t\tc += pow(max(0., 1. - m1), 30.) * .5;\t\t\n\t\tc += pow(max(0., 1. - m2), 30.) * .5;\t\t\n    }\n    g \/= 60.;\n    return c + (pow(g, 1.3) + pow(g,1.7) * .5) * atmo_color * .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) \/ iResolution.y;\n\tfloat a, b;\n    vec3 from = vec3(0., a, -10.);\n\tvec3 dir = normalize(vec3(uv, min(1.1, iTime * .5)));\n    vec3 col = march(from, dir);\n    \n    \/\/ Output to screen\n    fragColor = vec4(col*.85,1.0);\n}","name":"Image","description":"","type":"image"}]}]