[{"ver":"0.1","info":{"id":"wlt3WS","date":"1577487832","viewed":172,"name":"Eruption","username":"onlinerocker","description":"Don't touch the lava!","likes":2,"published":1,"flags":0,"usePreview":0,"tags":["raymarching","landscape","spheretracing","lava","volcano"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"#define PI 3.14159265359\n#define VIEW_DIST 50.0\n\/\/change VIEW_DIST for farther or shorter render distance\n\nstruct Object\n{\n \tfloat dist;\n    float difVal;\n    float specVal;\n    float specKs;\n    float normEps; \/\/artifacting was occuring for some objects when this value was too high\n    \t\t\t   \/\/thus, you can specify a value for each object.\n    vec3 color;\n    vec3 normal;\n    \n};\n\nstruct MarchRes\n{\n \tfloat totalDist;\n    vec3 curRay;\n    Object obj;\n};\n    \nstruct Light\n{\n\tfloat intensity;\n    vec3 color;\n    vec3 pos;  \n};\n \n\/\/https:\/\/www.shadertoy.com\/view\/4dS3Wd\nfloat hash(float p) { p = fract(p * 0.011); p *= p + 7.5; p *= p + p; return fract(p); }\n\n\/\/https:\/\/www.shadertoy.com\/view\/4dS3Wd\nfloat noise(vec3 x) {\n    const vec3 step = vec3(110, 241, 171);\n\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n \n    \/\/ For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    \/\/ incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(i, step);\n\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash(n + dot(step, vec3(0, 0, 1))), hash(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash(n + dot(step, vec3(0, 1, 1))), hash(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\n\/\/https:\/\/www.shadertoy.com\/view\/4dS3Wd\n\/\/slightly modified for octave spcification\nfloat fbm5(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 5; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\nfloat fbm3(vec3 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec3 shift = vec3(100);\n\tfor (int i = 0; i < 3; ++i) {\n\t\tv += a * noise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n\/\/iq\nfloat sdPlaneInf(vec3 pos, float y)\n{\n \treturn pos.y - y;   \n}\n\n\/\/iq, modified color and made fog amount grow exponentially, shrink as y gets bigger\nvec3 applyFog( in vec3  rgb,      \/\/ original color of the pixel\n               in float distance, \/\/ camera to point distance\n               in vec3  rayDir,   \/\/ camera to point vector\n               in vec3  sunDir )  \/\/ sun light direction\n{\n    float fogAmount = 1.0 - exp( -distance*(distance*(0.001 \/ pow(clamp(VIEW_DIST \/ 70.0, 0.0, 1.0), 2.0))) );\n    fogAmount -= rayDir.y;\n    float sunAmount = max( dot( rayDir, sunDir ), 0.0 );\n    vec3  fogColor  = mix( vec3(0.5,0.6,0.7), \/\/ bluish\n                           vec3(0.5,0.6,0.7), \n                           pow(sunAmount,8.0) );\n    return mix( rgb, fogColor, fogAmount );\n}\n\n\/\/https:\/\/iquilezles.org\/articles\/smin\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)\/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n    \nObject map(vec3 pos)\n{\n    Object o;\n    o.difVal = 1.0;\n    o.specVal = 20.0;\n    o.specKs = 0.0;\n    o.dist = 1000.0;\n    o.normEps = 0.001;\n    o.color = vec3(0);\n    \n    vec3 btmPos = pos;\n    btmPos.x += iTime*0.75;\n    btmPos.y -= 0.03*sin(btmPos.x*2.0);\n    float dPlaneBtm = sdPlaneInf(btmPos, 0.3);\n    if(dPlaneBtm < o.dist)\n    {\n        o.dist = dPlaneBtm;\n        \/\/o.color = vec3(1.0, 1.0, 0.1);\n        o.color = mix(vec3(1.0, 1.0, 0.1)*(1.3+abs(0.5*sin(iTime))), vec3(1.0, 0.1, 0.), fbm5(btmPos*3.0));\n    }\n\n\n    vec3 planePos = pos;\n    planePos.x += iTime;\n    float yVal = fbm3(planePos\/2.5);\n    yVal -= 0.2*fbm5(planePos*1.5);\n    planePos.y -= yVal;\n    float dPlane = sdPlaneInf(planePos, 0.0);\n    if(dPlane < o.dist)\n    {\n        o.dist = dPlane;\n\t\to.specKs = 0.15;\n        o.color = mix(vec3(1.0, 0.7, 0.1)*2.0, vec3(0.8, 0.1, 0.), smoothstep(0.0, 0.5, yVal));\n        o.color = mix(o.color, vec3(0.5, 0.1, 0.), smoothstep(0.4, 0.6, yVal));\n        \/\/o.color += mix(o.color, vec3(0), smoothstep(0.0, 1.0, yVal*fbm5(planePos*10.0)));\n    }\n\n    vec3 bbPos = pos;\n    bbPos.x = mod(bbPos.x, -5.0);\n    bbPos.z = abs(bbPos.z);\n    \n    return o;\n}\n\nvec3 calcNormal(vec3 pos, float ep)\n{\n    return normalize(vec3(map(pos + vec3(ep, 0, 0)).dist - map(pos - vec3(ep, 0, 0)).dist,\n                \t\tmap(pos + vec3(0, ep, 0)).dist - map(pos - vec3(0, ep, 0)).dist,\n                \t\tmap(pos + vec3(0, 0, ep)).dist - map(pos - vec3(0, 0, ep)).dist));                                \n}\n    \nMarchRes marchRay(vec3 pos, vec3 dir, float speed)\n{\n \tMarchRes res;\n    Object o;\n    \n    res.totalDist = 0.001;\n        \n    for(int x=0; x<100; x++)\n    {\n \t\tres.curRay = pos + (dir*res.totalDist);\n        \n        o = map(res.curRay);\n        if(abs(o.dist) < 0.0001)\n        {\n            res.obj = o;\n            break;\n        }\n        else if(res.totalDist >= VIEW_DIST) break;\n            \n        res.totalDist += o.dist*speed; \/\/ repalce 0.8 w\/ this for trippy mode ;p => (0.3+0.2*(sin(iTime))); \/\/couldn't handle the hair :' (\n    }\n    \n    if(res.totalDist < VIEW_DIST)\n    {\n        o.normal = calcNormal(res.curRay, o.normEps);\n        res.obj = o;\n    }\n    \t\n    \n    return res;\n}\n\nvec3 calcDiffuseLight(Object o, Light l, vec3 pos)\n{\n    vec3 dir = normalize(l.pos - pos);\n    return (o.color) * l.intensity * l.color * clamp(dot(o.normal, dir), 0.0, 1.0) * o.difVal;   \n}\n\nvec3 calcSpecLight(Object o, Light l, vec3 pos, vec3 camPos)\n{\n \tvec3 dir = normalize(l.pos - pos);  \n    vec3 viewDir = normalize(camPos - pos);\n    vec3 specR = 2.0*clamp( dot(o.normal, dir), 0.0, 1.0) * o.normal - dir;\n    float spec = clamp( dot(viewDir, specR), 0.0, 1.0);\n    \/\/lightInt*(lightCol*pow(lightSpec, res.obj.specVal))*res.obj.specKs * lightShadow;\n      \n    return o.specKs*l.intensity*(l.color*pow(spec, o.specVal));\n}\n\nvec3 drawVolcano(vec3 origCol, vec3 col, vec2 uv, vec2 yBound)\n{\n    uv.x = abs(uv.x);\n    return mix(origCol, col, smoothstep(uv.y, uv.y+0.01, yBound.x)\n               *smoothstep(uv.y-0.01, uv.y+0.01, pow(-uv.x*2.0 + 1.0,3.0) - 0.025)*step(yBound.y, uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord - iResolution.xy)\/iResolution.y;\n\tvec3 camEye = vec3(0.0,3.0,0.0);\n    vec3 dir = normalize(vec3(uv, -1));\n    \n\n    float camAng = 0.0;\/\/-iMouse.x\/20.0;\/\/\n    float camAngX = iMouse.y\/20.0;\n    \n    mat2 rotCam = mat2( vec2(cos(camAng), -sin(camAng)), vec2(sin(camAng), cos(camAng)) );\n    mat2 rotCamX = mat2( vec2(cos(camAng), sin(camAng)), vec2(-sin(camAng), cos(camAng)) );\n\n    \/\/vec2 camXZ = rotCam * camEye.xz;\n    \/\/camEye = vec3(camXZ.x, camEye.y, camXZ.y);\n    vec2 dirXZ = rotCam * dir.xz;\n    dir = vec3(dirXZ.x, dir.y, dirXZ.y);\n    \n    Light light;\n    light.intensity = 1.0;\n    light.pos = vec3(10, 5, -10.0);\n    light.color = vec3(1.0);\n    \n    Light lightSky;\n    lightSky.intensity = 0.3;\n    lightSky.pos = vec3(0, 3, 0);\n    lightSky.color = vec3(1);\n    \n\tMarchRes res = marchRay(camEye, dir, 1.0);\n    vec3 pos = res.curRay;  \n    \n    float y = uv.y + 1.0;\n    y = y \/ 1.62;\n    y = clamp(y, 0.7, 1.0);\n    \n    y = smoothstep(1.1, 0.5, y);\n    vec3 col = (vec3(1)*(y) + vec3(0.3, 0.3, 0.4)*(1.0-y));\n    \/\/col = vec3(0);\n    vec3 volCol = mix(vec3(0.3, 0.3, 0.4), vec3(0.83, 0.35, 0.35)*abs(1.0 + 0.3*sin(iTime)), smoothstep(0.37, 0.4, uv.y));\n    col = drawVolcano(col, volCol, uv, vec2(0.4, -0.3));\n\n    if(res.totalDist < VIEW_DIST)\n    {\n        col = calcDiffuseLight(res.obj, light, vec3(0)) + calcDiffuseLight(res.obj, lightSky, vec3(0,0,0));\n        col += calcSpecLight(res.obj, light, pos, camEye);\/\/ * calcShadowSoft(pos, light);\n    }\n    \n    col = applyFog(col, length(pos), normalize(pos), normalize(light.pos - pos));\n    \n    fragColor = vec4(col,1.0);\n}","name":"Image","description":"","type":"image"}]}]