[{"ver":"0.1","info":{"id":"XdGGWz","date":"1453987761","viewed":1232,"name":"Interactive Shiny spheres","username":"iapafoto","description":"mix between shaderology shader [https:\/\/www.shadertoy.com\/view\/ltjGDd]\nand dr2 shader  [https:\/\/www.shadertoy.com\/view\/Xsy3WR]\nMouse available","likes":87,"published":1,"flags":32,"usePreview":0,"tags":["collision","dynamics","physics"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ mix between shaderology shader [https:\/\/www.shadertoy.com\/view\/ltjGDd]\n\/\/ and dr2 shader  [https:\/\/www.shadertoy.com\/view\/Xsy3WR]\n\n\n#define BIAS 0.0001\n#define PI 3.1415927\n#define SEED 4.\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\n#define ZERO min(0,iFrame)\n\nconst int SPH = 16;\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nconst float pi = 3.14159;\n\nvec3 \/*pMol[nMol],*\/ ltDir, rdSign;\nfloat dstFar, hbLen;\nint idObj;\nbool isRefl;\n\n\n\/\/ returns t and normal\nfloat iBox( in vec3 roo, in vec3 rdd, in vec3 rad, out float tN, out float tF, out vec3 nN, out vec3 nF) \n{\n\t\/\/ ray-box intersection in box space\n    vec3 m = 1.0\/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) \n        return -1.;\n\n\tnN = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\tnF = -sign(rdd)*(1.-step(t2.yzx,t2.xyz))*(1.-step(t2.zxy,t2.xyz));\n\n\treturn 1.;\n}\n\n\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n  vec3 oc = ro - sph.xyz;\n  float b = dot( oc, rd );\n  float c = dot( oc, oc ) - sph.w*sph.w;\n  float h = b*b - c;\n  if( h<0.0 ) return -1.0;\n  return -b - sqrt( h );\n}\n\nfloat sphOcclusion( in vec3 pos, in vec3 nor, in vec4 sph )\n{\n    vec3  r = sph.xyz - pos;\n    float l = length(r);\n    float d = dot(nor,r);\n    float res = d;\n\n    if( d<sph.w ) res = pow(clamp((d+sph.w)\/(2.0*sph.w),0.0,1.0),1.5)*sph.w;\n    \n    return clamp( res*(sph.w*sph.w)\/(l*l*l), 0.0, 1.0 );\n}\n\n\nfloat sphAreaShadow( vec3 P, in vec4 L, vec4 sph )\n{\n  vec3 ld = L.xyz - P;\n  vec3 oc = sph.xyz - P;\n  float r = sph.w - BIAS;\n  \n  float d1 = sqrt(dot(ld, ld));\n  float d2 = sqrt(dot(oc, oc));\n  \n  if (d1 - L.w \/ 2. < d2 - r) return 1.;\n  \n  float ls1 = L.w \/ d1;\n  float ls2 = r \/ d2;\n\n  float in1 = sqrt(1.0 - ls1 * ls1);\n  float in2 = sqrt(1.0 - ls2 * ls2);\n  \n  if (in1 * d1 < in2 * d2) return 1.;\n  \n  vec3 v1 = ld \/ d1;\n  vec3 v2 = oc \/ d2;\n  float ilm = dot(v1, v2);\n  \n  if (ilm < in1 * in2 - ls1 * ls2) return 1.0;\n  \n  float g = length( cross(v1, v2) );\n  \n  float th = clamp((in2 - in1 * ilm) * (d1 \/ L.w) \/ g, -1.0, 1.0);\n  float ph = clamp((in1 - in2 * ilm) * (d2 \/ r) \/ g, -1.0, 1.0);\n  \n  float sh = acos(th) - th * sqrt(1.0 - th * th) \n           + (acos(ph) - ph * sqrt(1.0 - ph * ph))\n           * ilm * ls2 * ls2 \/ (ls1 * ls1);\n  \n  return 1.0 - sh \/ PI;\n}\n\n\n\/\/-------------------------------------------------------------------------------------------\n\n\nvec4 sphere[SPH];\nvec4 L;\n\nvec3 rand3( float x, float seed )\n{ \n  float f = x+seed;\n  return fract( PI*sin( vec3(f,f+5.33,f+7.7)) );\n}\n\nfloat areaShadow( in vec3 P )\n{\n  float s = 1.0;\n  for( int i=0; i<SPH; i++ )\n    s = min( s, sphAreaShadow(P, L, sphere[i] ) );\n  return s;           \n}\n\nvec3 reflections( vec3 P, vec3 R, vec3 tint, int iid )\n{\n  float t = 1e20;\n\n  vec3 s = vec3(.5); \/\/vec3(R.y < 0. ? 1.-sqrt(-R.y\/(P.y+1.)) : 1.); \/\/ P.y+1 floor pos\n  for( int i=ZERO; i<SPH; i++ ) {    \n    float h = sphIntersect( P, R, sphere[i] );\n    if( h>0.0 && h<t ) {\n      s = i == iid ? tint * 2. : vec3(0.);\n      t = h;        \n    }\n  }     \n  return max(vec3(0.), s);           \n}\n\nfloat occlusion( vec3 P, vec3 N ) {\n  float s = 1.0;\n  for( int i=ZERO; i<SPH; i++ )\n    s *= 1.0 - sphOcclusion( P, N, sphere[i] ); \n  return s;           \n}\n\nfloat sphLight( vec3 P, vec3 N, vec4 L) {\n  vec3 oc = L.xyz  - P;\n  float dst = sqrt( dot( oc, oc ));\n  vec3 dir = oc \/ dst;\n  \n  float c = dot( N, dir );\n  float s = L.w  \/ dst;\n    \n  return max(0., c * s);\n}\n  \n\/\/-------------------------------------------------------------------------------------------\n\nvec3 shade( vec3 I, vec3 P, vec3 N, float id, float iid ) {\n    \n  vec3 base = rand3( id, SEED );\n  vec3 wash = mix( vec3(0.9), base, 0.4);\n  vec3 hero = rand3( iid, SEED );\n  \n  vec3 ref = reflections( P, I - 2.*(dot(I,N))*N, hero, int(iid) );\n  float occ = occlusion( P, N );\n \/\/ float ocf = 1.-sqrt((0.5 + 0.5*-N.y)\/(P.y+1.25))*.5; \/\/floor occusion. 1.25 floor P.\n  float fre = clamp( 1. + dot( I, N), 0., 1.); \n        fre = (0.01+0.4*pow(fre,3.5));\n    \n  float lgh = sphLight( P, N, L) * areaShadow( P );\n  float inc = ( id == iid ? 1.0 : 0.0 );\n   \n  \/\/ Env light\n  vec3 C = wash * occ*.2; \/\/ * ocf * .2;\n  \n  \/\/ Sphere light\n  C += ( inc + lgh * 1.3 ) * hero;\n\n  \/\/ Reflections\n  C = mix( .3*C, ref, fre );\n  \n  return C;\n}    \n\nvec3 trace( vec3 E, vec3 I, vec3 C, float px, float iid)\n{\n  float t = 1e20;\n  float id  = -1.0;\n  vec4  obj = vec4(0.);\n  for( int i=ZERO; i<SPH; i++ ) {\n    vec4 sph = sphere[i];\n    float h = sphIntersect( E, I, sph ); \n    if( h>0.0 && h<t ) \n    {\n      t = h;\n      obj = sph;\n      id = float(i);\n    }\n  }\n              \n  if( id>-0.5 )\n  {\n    vec3 P = E + t*I;\n    vec3 N = normalize(P-obj.xyz);\n    C = shade( I, P, N, id, iid  );\n  }\n\n  return C;\n}\n\n\nvoid GetMols() {\n  for (int n = ZERO; n < SPH; n ++) \n      sphere[n] = Loadv4 (2 * n);\n  hbLen = Loadv4 (2 * SPH).y;\n}\n\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 qtVu;\n  vec3 col, rd, ro;\n  vec2 canvas, uv, ut;\n  float tCur;\n    \n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy \/ canvas - 1.;\n  uv.x *= canvas.x \/ canvas.y;\n    \n  tCur = iTime;\n  ut = abs (uv) - vec2 (1.);\n  \/\/if (max (ut.x, ut.y) > 0.003) col = vec3 (0.82);\n  \/\/else {\n    \n    float fov = 4.;\n    dstFar = 100.;\n    qtVu = Loadv4 (2 * SPH + 1);\n    vuMat = QToRMat (qtVu);\n    rd = normalize (vec3 (uv, fov)) * vuMat;\n    ro = vec3 (0., 0., -18.) * vuMat;\n    ltDir = normalize (vec3 (1., 1.5, -1.2)) * vuMat;\n   \n    \n    GetMols();\n    \n\n    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n    vec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)\/iResolution.y;\n    vec2 m = step(0.0001,iMouse.z) * iMouse.xy\/iResolution.xy;\n    \n    \/\/-----------------------------------------------------\n    \n    float time = iTime+1.;  \n    float spI = floor(mod(time,float(SPH)));\n    float sec = mod(time,1.);\n    \/\/-----------------------------------------------------\n    for( int i=ZERO; i<SPH; i++ ) {\n\n      \tif( i == int(spI) )\t{\n             sphere[i].w += .02*sin(sec*50.) \/ sqrt(sec) * ( 1.-sqrt(sec));\n\n        \tL = sphere[i];\n      \t}\n    }\n\n    \/\/-----------------------------------------------------\n    \n\n    float px = 1.0*(2.0\/iResolution.y)*(1.0\/fov);\n\n    vec3 C = vec3(.2);\n\n    float tN, tF;\n    vec3 nN, nF;\n\n    if (iBox(ro, rd, vec3(hbLen-.9), tN, tF, nN, nF)>0.) {\n        C += .4*shade(rd, ro + tF*rd, nF, px, spI);\n\t\tC = trace( ro, rd, C, px, spI);       \n        C += .4*shade(rd, ro + tN*rd, nN, px, spI );\n    }\n    \n    \/\/-----------------------------------------------------\n\n    \/\/ post\n    C = pow( C, vec3(0.41545) );   \n    C *= pow(18.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.12);\n\n    fragColor = vec4( C, 1. );\n}\n\n\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":"4dXGR8","filepath":"\/media\/previz\/buffer00.png","previewfilepath":"\/media\/previz\/buffer00.png","type":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dXGR8","channel":0}],"code":"\/\/ \"Reflecting Balls\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\/\/ iapafoto : adaptation to enable various ball size and realistic behaviours\n\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n#define ZERO min(0,iFrame)\n\n\nconst float pi = 3.14159;\nconst int SPH = 16;\n\n\nvec4 QMul (vec4 q1, vec4 q2)\n{\n  return vec4 (\n     q1.w * q2.x - q1.z * q2.y + q1.y * q2.z + q1.x * q2.w,\n     q1.z * q2.x + q1.w * q2.y - q1.x * q2.z + q1.y * q2.w,\n   - q1.y * q2.x + q1.x * q2.y + q1.w * q2.z + q1.z * q2.w,\n   - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z + q1.w * q2.w);\n}\n\nmat3 QToRMat (vec4 q) \n{\n  mat3 m;\n  float a1, a2, s;\n  s = q.w * q.w - 0.5;\n  m[0][0] = q.x * q.x + s;  m[1][1] = q.y * q.y + s;  m[2][2] = q.z * q.z + s;\n  a1 = q.x * q.y;  a2 = q.z * q.w;  m[0][1] = a1 + a2;  m[1][0] = a1 - a2;\n  a1 = q.x * q.z;  a2 = q.y * q.w;  m[2][0] = a1 + a2;  m[0][2] = a1 - a2;\n  a1 = q.y * q.z;  a2 = q.x * q.w;  m[1][2] = a1 + a2;  m[2][1] = a1 - a2;\n  return 2. * m;\n}\n\nvec4 EulToQ (vec3 e)\n{\n  float a1, a2, a3, c1, s1;\n  a1 = 0.5 * e.y;  a2 = 0.5 * (e.x - e.z);  a3 = 0.5 * (e.x + e.z);\n  s1 = sin (a1);  c1 = cos (a1);\n  return normalize (vec4 (s1 * cos (a2), s1 * sin (a2), c1 * sin (a3),\n     c1 * cos (a3)));\n}\n\nfloat Hashff (float p)\n{\n  const float cHashM = 43758.54;\n  return fract (sin (p) * cHashM);\n}\n\nconst float txRow = 64.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi \/ txRow)) + 0.5) \/\n     txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  float fi = float (idVar);\n  vec2 d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi \/ txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n\nvec4 qtVu;\nfloat hbLen;\n\nvoid Step (int mId, out vec3 r, out vec3 v)\n{\n  vec3 rn, vn, dr, f;\n  float fOvlap, fDamp, grav, rSep, dt;\n  fOvlap = 1000.;\n  fDamp = 7.;\n  grav = 50.;\n    \n  vec4 ll0 = Loadv4 (2 * mId);\n  float rtot;  \n  r = ll0.xyz;\n  v = Loadv4 (2 * mId + 1).xyz;\n  f = vec3 (0.);\n \n  for (int n = ZERO; n < SPH; n ++) {\n    vec4 ll = Loadv4 (2 * n);\n    rn = ll.xyz;\n    dr = r - rn;\n    rSep = length (dr);\n    rtot = ll0.w + ll.w;\n    if (n != mId && rSep < rtot) f += fOvlap * (rtot \/ rSep - 1.) * dr;\n  }\n    \n  dr = hbLen - abs(r) - ll0.w;\n  f -= step (dr, vec3 (1.)) * fOvlap * sign (r) * (1. \/ abs (dr) - 1.) * dr +\n      vec3 (0., grav, 0.) * QToRMat (qtVu) + fDamp * v;\n  dt = .02; \/\/iTimeDelta; \/\/*\/0.02;\n  v += dt * f;\n  r += dt * v;\n}\n\nvec3 VInit (int n)\n{\n  float fn;\n  fn = float (n);\n  return 2. * normalize (vec3 (Hashff (fn), Hashff (fn + 0.3),\n     Hashff(fn + 0.6)) - 0.5);\n}\n\nvoid OrientVu (inout vec4 qtVu, vec4 mPtr, inout vec4 mPtrP, bool init)\n{\n  vec3 vq1, vq2;\n  vec2 dm;\n  float mFac;\n  if (! init) {\n    qtVu = vec4 (0., 0., 0., 1.);\n    mPtrP = vec4 (99.,0., -1., 0.);\n      \n  } else {\n      \n    if (mPtr.z > 0.) {\n      if (mPtrP.x == 99.) mPtrP = mPtr;\n      mFac = 1.5;\n      dm = - mFac * mPtrP.xy;\n      vq1 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      dm = - mFac * mPtr.xy;\n      vq2 = vec3 (dm, sqrt (max (1. - dot (dm, dm), 0.)));\n      qtVu = normalize(QMul (vec4 (cross (vq1, vq2), dot (vq1, vq2)), qtVu));\n      mPtrP = mPtr;\n    } else mPtrP = vec4 (99., 0., -1., 0.);\n  }\n}\n\nvoid Init (int mId, out vec3 r, out vec3 v)\n{\n  float fm, fme, fn;\n  fme = 3.;\n  fm = float (mId);\n  r = 1.5 * floor (vec3 (mod (fm, fme), mod (fm, fme * fme) \/ fme,\n     fm \/ (fme * fme))) - 0.5 * (fme - 1.);\n  v = VInit (mId);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat;\n  vec3 p, r, v;\n  float tCur;\n  int mId, pxId;\n  bool doInit;\n  vec2 kv = floor (fragCoord);\n  pxId = int (kv.x + txRow * kv.y);\n \n  if (kv.x >= txRow || pxId > 2 * SPH + 2) discard;\n    \n    \n  tCur = 5.*(1.+.5*sin(.5*iTime))+2.*iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy \/ iResolution.xy - 0.5;\n    \n  qtVu = Loadv4 (2 * SPH + 1);\n  mPtrP = Loadv4 (2 * SPH + 2);\n    \n  mId = pxId \/ 2;\n  doInit = false;\n    \n  if (iFrame < 2) {\n    hbLen = 3.5;\n\n    OrientVu(qtVu, mPtr, mPtrP, false);\n          \n    float sphereSize = .5; \/\/.2+.15*\/*floor*\/(.15*float(pxId)); \n    stDat = vec4(0., hbLen, tCur, sphereSize);\n \n    if (mId < SPH) \n        doInit = true;\n      \n  } else {\n      \n    OrientVu (qtVu, mPtr, mPtrP, true);\n    stDat = Loadv4 (2 * SPH);\n    ++stDat.x;\n    hbLen = stDat.y;\n      \n    if (mPtrP.z < 0.) \n        qtVu = normalize(QMul (EulToQ (0.2 * (tCur - stDat.z) * pi * vec3 (-0.27, -0.34, -0.11)), qtVu));\n      \n      \n    stDat.z = tCur;\n    if (mId < SPH) {\n      Step (mId, r, v);\n      p = (2 * mId == pxId) ? r : v;\n    }\n  }\n    \n    \n  if (doInit) {\n    Init (mId, r, v);\n    p = (2 * mId == pxId) ? r : v;\n  }\n    \n  if (pxId == 2 * SPH + 1) stDat = qtVu;\n  else if (pxId == 2 * SPH + 2) stDat = mPtrP;\n  \n  float sphereSize = .1+.12*(.15*float(pxId));\n    \n  float time = iTime + 1.;\n  float spI = floor(mod(time, float(SPH)));\n  float an = 0.3*time;\n  float sec = mod(time,1.);\n\n  for( int i=ZERO; i<SPH; i++) {\n  \tif (i == int(spI) ) {\n        sphereSize += .41*smoothstep(.4,.8,fract(time*.08));\n    }\n  }\n \/\/ if (pxId == int(spI) ) {\n \/\/    sphereSize += .01*sin(sec*50.) \/ sqrt(sec) * ( 1.-sqrt(sec));\n \/\/ }  \n    \n  Savev4 (pxId, ((pxId < 2 * SPH) ? vec4 (p, sphereSize) : stDat), fragColor, fragCoord);\n   \n}\n","name":"Buffer A","description":"","type":"buffer"}]}]