[{"ver":"0.1","info":{"id":"fl2Bzd","date":"1677789964","viewed":1052,"name":"Planetary nebula","username":"nimitz","description":"Been wanting to try my hand at rendering a somewhat realistic planetary nebula for a while, here it is. Also showing off the latest version of my procedural starfield algorithm (note the lack of star flickering).","likes":62,"published":1,"flags":0,"usePreview":0,"tags":["volumetric","stars","nebula"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Planetary nebula by nimitz 2023 (twitter: @stormoid)\n\/\/ https:\/\/www.shadertoy.com\/view\/fl2Bzd\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/ Contact the author for other licensing options\n\n\/*\n    The main trick for the nebula rendering is to compute SDF curvature to allow for rendering of \"ambient occlusion\"\n    of the star light in the surrounding volume, which really helps the overall look.\n    \n    The star function maps to cube faces allowing for star patterns while only being a few layers of displaced dots\n*\/\n\nmat3 rot_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rot_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nconst mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*2.1;\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\n\n\/\/#define HIGH_QUALITY\n\nfloat map(vec3 p)\n{\n    p.yz *= mm2(-0.37);\n    vec3 dz = vec3(p.z*.0,p.z*.0,p.z*.75);\n    float cl = -abs(dot(p ,p-dz*1. )-10.0) + 2.0;\n    float cl2 = -dot(p.xy,p.xy) + 7.0;\n    cl = mix(cl,cl2,.35);\n    \n    float d = 0.;\n    p *= 0.54;\n    float z = 3.5;\n    float trk = 1.;\n    for(int i = 0; i < 5; i++)\n    {\n        p += sin(p.zxy*trk - 0.5)*0.25;\n        d -= abs(dot(cos(p), sin(p.zxy + 0.6)) - .3)*z - 1.8;\n        z *= 0.7;\n        p = p*m3;\n        trk *= 1.45;\n    }\n\n    return clamp(d*.9 + cl*.9,-20.,1000.);\n}\n\nfloat curv(in vec3 p, in float p0, in float w)\n{\n    vec2 e = vec2(-1., 1.)*w;   \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    return .25\/e.y*(t1 + t2 + t3 + t4 - 4.0*p0);\n}\n\nfloat linstep(in float mn, in float mx, in float x){return clamp((x - mn)\/(mx - mn), 0., 1.);}\n\nvec4 render( in vec3 ro, in vec3 rd )\n{\n\tvec4 rez = vec4(0);\n#ifdef HIGH_QUALITY\n    float t = 8;\n\tfor(int i=0; i<120; i++)\n#else\n    float t = 9.;\n    for(int i=0; i<95; i++)\n#endif\n\t{\n\t\tif(rez.a > 0.95 || t > 17.)break;\n\n\t\tvec3 pos = ro + t*rd;\n        float dtp = dot(pos,pos);\n        float dn = map(pos);\n\t\tfloat den = clamp(dn, 0.0, 1.3);\n\n        float ext = linstep(60.,15.,dtp);\n        float dt2 = linstep(0.,30.,dtp)+0.35;\n        float crv = linstep(-3.5,-15., curv(pos*.75, dn, .65*dt2))*0.5+0.035;\n        \n        vec4 col = vec4((sin(vec3(3.7,1.7,.9) + dtp*0.03+4.9)*vec3(0.4,0.17,0.25)+vec3(0.2,0.01,0.1)) ,0.05)*den;\n        col.xyzw *= vec4(0.25,0.37,.3,1.)*crv*ext;\n        \n        float dif =  clamp((map(pos * 1.09)- dn)*1.2, -.8, 6. );\n        col.xyz *= vec3(1.) + vec3(.9,.8,.7)*dif;\n        \n        col.rgba += vec4(.75,.6,.5, 0.01)*clamp(0.07\/dtp, 0., 5.)*(crv*0. + .2)*smoothstep(7.,-5.,dtp);\n        rez = rez + col*(1. - rez.a);\n        \n        t += clamp(0.06 - den*.1, 0.065, 0.15);\n        \n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nvec4 hash43x(vec3 p)\n{\n    uvec3 x = uvec3(ivec3(p));\n    x = 1103515245U*((x.xyz >> 1U)^(x.yzx));\n    uint h = 1103515245U*((x.x^x.z)^(x.y>>3U));\n    uvec4 rz = uvec4(h, h*16807U, h*48271U, h*69621U); \/\/see: http:\/\/random.mat.sbg.ac.at\/results\/karl\/server\/node4.html\n    return vec4((rz >> 1) & uvec4(0x7fffffffU))\/float(0x7fffffff);\n}\n\n\n\/*  Very happy with this new star function, allows for constellations, low artifacts and \"cheap\" to evaluate\n    Probably the nicest trick here is rendering on a \"cube\", and making sure the random displacement is bounded\n    to the surface of the evaluated cube by selecting the correct displacement plane analytically\n    Another great benefit is that the cube projection gives an non-uniform distribution for a single layer,\n    by rotating the successive layers, the result ends up being more natural looking with visible large-scale structure.\n*\/\nvec3 stars(vec3 p)\n{\n    vec3 col = vec3(0);\n    float rad = .087*iResolution.y;\n    float dens = 0.15;\n    float id = 0.;\n    float rz = 0.;\n    float z = 1.;\n    \n    for (float i = 0.; i < 5.; i++)\n    {\n        p *= mat3(0.86564, -0.28535, 0.41140, 0.50033, 0.46255, -0.73193, 0.01856, 0.83942, 0.54317);\n        vec3 q = abs(p);\n        vec3 p2 = p\/max(q.x, max(q.y,q.z));\n        p2 *= rad;\n        vec3 ip = floor(p2 + 1e-5);\n        vec3 fp = fract(p2 + 1e-5);\n        vec4 rand = hash43x(ip*283.1);\n        vec3 q2 = abs(p2);\n        vec3 pl = 1.0- step(max(q2.x, max(q2.y, q2.z)), q2);\n        vec3 pp = fp - ((rand.xyz-0.5)*.6 + 0.5)*pl; \/\/don't displace points away from the cube faces\n        float pr = length(ip) - rad;   \n        if (rand.w > (dens - dens*pr*0.035)) pp += 1e6;\n\n        float d = dot(pp, pp);\n        d \/= pow(fract(rand.w*172.1), 32.) + .25;\n        float bri = dot(rand.xyz*(1.-pl),vec3(1)); \/\/since one random value is unused to displace, we can reuse\n        id = fract(rand.w*101.);\n        col += bri*z*.00009\/pow(d + 0.025, 3.0)*(mix(vec3(1.0,0.45,0.1),vec3(0.75,0.85,1.), id)*0.6+0.4);\n        \n        rad = floor(rad*1.08);\n        dens *= 1.45;\n        z *= 0.6;\n        p = p.yxz;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 q = fragCoord.xy \/ iResolution.xy;\n    vec2 p = q - 0.5;\n\tp.x*=iResolution.x\/iResolution.y;\n\tvec2 mo = iMouse.xy \/ iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(-0.25,0.15):mo;\n\tmo.x *= iResolution.x\/iResolution.y;\n    mo*=3.14;\n\tmo.y = clamp(mo.y*0.6-.5,-4. ,.15 );\n\t\n    vec3 ro = vec3(0.,-0.0,12.);\n    vec3 rd = normalize(vec3(p,-1.4));\n    \n    mat3 cam = rot_x(-mo.y)*rot_y(-mo.x + sin(iTime*0.2)*0.15);\n\trd *= cam;\n    ro *= cam;\n    \n    vec4 scn = render(ro, rd);\n    vec3 col = vec3(0.1, 0.1, 0.11)*smoothstep(-1.,1.,rd.y)*0.;\n    col = stars(rd);\n    \n    col = col*(1.0-scn.w) + scn.xyz;\n\n    col = pow(col, vec3(.5));\n    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12); \/\/Vign\n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"}]}]