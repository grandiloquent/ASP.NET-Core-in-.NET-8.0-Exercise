[{"ver":"0.1","info":{"id":"lty3Rt","date":"1476125205","viewed":21459,"name":"Pegasus Galaxy","username":"frankenburgh","description":"Galaxy shader from Pegasus 4k Intro\n4kb executable: http:\/\/www.pouet.net\/prod.php?which=65859\nhttps:\/\/www.youtube.com\/watch?v=3pXhImWoNsw","likes":260,"published":1,"flags":64,"usePreview":1,"tags":["clouds","space","galaxy","stars","demsoscene","nebular"],"hasliked":0,"parentid":"","parentname":""},"renderpass":[{"inputs":[{"id":"ldB3Rm","filepath":"https:\/\/soundcloud.com\/virgill\/4k-galaxy-pegasus-soundtrack","previewfilepath":"https:\/\/soundcloud.com\/virgill\/4k-galaxy-pegasus-soundtrack","type":"musicstream","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"},"published":1}],"outputs":[{"id":"4dfGRr","channel":0}],"code":"\/\/ Galaxy shader\n\/\/\n\/\/ Created by Frank Hugenroth  \/frankenburgh\/   07\/2015\n\/\/ Released at nordlicht\/bremen 2015\n\n#define SCREEN_EFFECT 0\n\n\/\/ random\/hash function              \nfloat hash( float n )\n{\n  return fract(cos(n)*41415.92653);\n}\n\n\/\/ 2d noise function\nfloat noise( in vec2 x )\n{\n  vec2 p  = floor(x);\n  vec2 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0;\n\n  return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y);\n}\n\nfloat noise( in vec3 x )\n{\n  vec3 p  = floor(x);\n  vec3 f  = smoothstep(0.0, 1.0, fract(x));\n  float n = p.x + p.y*57.0 + 113.0*p.z;\n\n  return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n    mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n    mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\nmat3 m = mat3( 0.00,  1.60,  1.20, -1.60,  0.72, -0.96, -1.20, -0.96,  1.28 );\n\n\/\/ Fractional Brownian motion\nfloat fbmslow( vec3 p )\n{\n  float f = 0.5000*noise( p ); p = m*p*1.2;\n  f += 0.2500*noise( p ); p = m*p*1.3;\n  f += 0.1666*noise( p ); p = m*p*1.4;\n  f += 0.0834*noise( p ); p = m*p*1.84;\n  return f;\n}\n\nfloat fbm( vec3 p )\n{\n  float f = 0., a = 1., s=0.;\n  f += a*noise( p ); p = m*p*1.149; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); p = m*p*1.51; s += a; a *= .65;\n  f += a*noise( p ); p = m*p*1.21; s += a; a *= .35;\n  f += a*noise( p ); p = m*p*1.41; s += a; a *= .75;\n  f += a*noise( p ); \n  return f\/s;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime * 0.1;\n\n\tvec2 xy = -1.0 + 2.0*fragCoord.xy \/ iResolution.xy;\n\n\t\/\/ fade in (1=10sec), out after 8=80sec;\n\tfloat fade = min(1., time*1.)*min(1.,max(0., 15.-time));\n\t\/\/ start glow after 5=50sec\n\tfloat fade2= max(0., time-10.)*0.37;\n\tfloat glow = max(-.25,1.+pow(fade2, 10.) - 0.001*pow(fade2, 25.));\n\t\n\t\n\t\/\/ get camera position and view direction\n\tvec3 campos = vec3(500.0, 850., -.0-cos((time-1.4)\/2.)*2000.); \/\/ moving\n\tvec3 camtar = vec3(0., 0., 0.);\n\t\n\tfloat roll = 0.34;\n\tvec3 cw = normalize(camtar-campos);\n\tvec3 cp = vec3(sin(roll), cos(roll),0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = normalize(cross(cu,cw));\n\tvec3 rd = normalize( xy.x*cu + xy.y*cv + 1.6*cw );\n\n\tvec3 light   = normalize( vec3(  0., 0.,  0. )-campos );\n\tfloat sundot = clamp(dot(light,rd),0.0,1.0);\n\n\t\/\/ render sky\n\n    \/\/ galaxy center glow\n    vec3 col = glow*1.2*min(vec3(1.0, 1.0, 1.0), vec3(2.0,1.0,0.5)*pow( sundot, 100.0 ));\n    \/\/ moon haze\n    col += 0.3*vec3(0.8,0.9,1.2)*pow( sundot, 8.0 );\n\n\t\/\/ stars\n\tvec3 stars = 85.5*vec3(pow(fbmslow(rd.xyz*312.0), 7.0))*vec3(pow(fbmslow(rd.zxy*440.3), 8.0));\n\t\n\t\/\/ moving background fog\n    vec3 cpos = 1500.*rd + vec3(831.0-time*30., 321.0, 1000.0);\n    col += vec3(0.4, 0.5, 1.0) * ((fbmslow( cpos*0.0035 ) - .5));\n\n\tcpos += vec3(831.0-time*33., 321.0, 999.);\n    col += vec3(0.6, 0.3, 0.6) * 10.0*pow((fbmslow( cpos*0.0045 )), 10.0);\n\n\tcpos += vec3(3831.0-time*39., 221.0, 999.0);\n    col += 0.03*vec3(0.6, 0.0, 0.0) * 10.0*pow((fbmslow( cpos*0.0145 )), 2.0);\n\n\t\/\/ stars\n\tcpos = 1500.*rd + vec3(831.0, 321.0, 999.);\n\tcol += stars*fbm(cpos*0.0021);\n\t\n\t\n\t\/\/ Clouds\n    vec2 shift = vec2( time*100.0, time*180.0 );\n    vec4 sum = vec4(0,0,0,0); \n    float c = campos.y \/ rd.y; \/\/ cloud height\n    vec3 cpos2 = campos - c*rd;\n    float radius = length(cpos2.xz)\/1000.0;\n\n    if (radius<1.8)\n    {\n  \t  for (int q=10; q>-10; q--) \/\/ layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*8.-campos.y) \/ rd.y; \/\/ cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t\/\/ border\n \t    float radius = length(cpos.xz)\/999.;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.00*(radius)-time;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); \/\/ cloud position\n\t\tcpos *= mix(0.0025, 0.0028, radius); \/\/ zoom\n      \tfloat alpha = smoothstep(0.50, 1.0, fbm( cpos )); \/\/ fractal cloud density\n\t  \talpha *= 1.3*pow(smoothstep(1.0, 0.0, radius), 0.3); \/\/ fade out disc at edges\n\t  \tvec3 dustcolor = mix(vec3( 2.0, 1.3, 1.0 ), vec3( 0.1,0.2,0.3 ), pow(radius, .5));\n      \tvec3 localcolor = mix(dustcolor, shine, alpha); \/\/ density color white->gray\n\t\t  \n\t\tfloat gstar = 2.*pow(noise( cpos*21.40 ), 22.0);\n\t\tfloat gstar2= 3.*pow(noise( cpos*26.55 ), 34.0);\n\t\tfloat gholes= 1.*pow(noise( cpos*11.55 ), 14.0);\n\t\tlocalcolor += vec3(1.0, 0.6, 0.3)*gstar;\n\t\tlocalcolor += vec3(1.0, 1.0, 0.7)*gstar2;\n\t\tlocalcolor -= gholes;\n\t\t  \n        alpha = (1.0-sum.w)*alpha; \/\/ alpha\/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); \/\/ sum up weightened color\n\t  }\n\t\t\n  \t  for (int q=0; q<20; q++) \/\/ 120 layers\n      {\n\t\tif (sum.w>0.999) continue;\n        float c = (float(q)*4.-campos.y) \/ rd.y; \/\/ cloud height\n        vec3 cpos = campos + c*rd;\n\n   \t\tfloat see = dot(normalize(cpos), normalize(campos));\n\t\tvec3 lightUnvis = vec3(.0,.0,.0 );\n\t\tvec3 lightVis   = vec3(1.3,1.2,1.2 );\n\t\tvec3 shine = mix(lightVis, lightUnvis, smoothstep(0.0, 1.0, see));\n\n\t\t\/\/ border\n \t    float radius = length(cpos.xz)\/200.0;\n\t    if (radius>1.0)\n\t      continue;\n\n\t\tfloat rot = 3.2*(radius)-time*1.1;\n      \tcpos.xz = cpos.xz*mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n \t\n\t\tcpos += vec3(831.0+shift.x, 321.0+float(q)*mix(250.0, 50.0, radius)-shift.x*0.2, 1330.0+shift.y); \/\/ cloud position\n      \tfloat alpha = 0.1+smoothstep(0.6, 1.0, fbm( cpos )); \/\/ fractal cloud density\n\t  \talpha *= 1.2*(pow(smoothstep(1.0, 0.0, radius), 0.72) - pow(smoothstep(1.0, 0.0, radius*1.875), 0.2)); \/\/ fade out disc at edges\n      \tvec3 localcolor = vec3(0.0, 0.0, 0.0); \/\/ density color white->gray\n  \n        alpha = (1.0-sum.w)*alpha; \/\/ alpha\/density saturation (the more a cloud layer\\\\\\'s density, the more the higher layers will be hidden)\n        sum += vec4(localcolor*alpha, alpha); \/\/ sum up weightened color\n\t  }\n    }\n\tfloat alpha = smoothstep(1.-radius*.5, 1.0, sum.w);\n    sum.rgb \/= sum.w+0.0001;\n    sum.rgb -= 0.2*vec3(0.8, 0.75, 0.7) * pow(sundot,10.0)*alpha;\n    sum.rgb += min(glow, 10.0)*0.2*vec3(1.2, 1.2, 1.2) * pow(sundot,5.0)*(1.0-alpha);\n\n   \tcol = mix( col, sum.rgb , sum.w);\/\/*pow(sundot,10.0) );\n\n    \/\/ haze\n\tcol = fade*mix(col, vec3(0.3,0.5,.9), 29.0*(pow( sundot, 50.0 )-pow( sundot, 60.0 ))\/(2.+9.*abs(rd.y)));\n\n#if SCREEN_EFFECT == 1\n    if (time<2.5)\n    {\n    \t\/\/ screen effect\n    \tfloat c = (col.r+col.g+col.b)* .3 * (.6+.3*cos(gl_FragCoord.y*1.2543)) + .1*(noise((xy+time*2.)*294.)*noise((xy-time*3.)*321.));\n   \t    c += max(0.,.08*sin(10.*time+xy.y*7.2543));\n        \/\/ flicker\n\t\tcol = vec3(c, c, c) * (1.-0.5*pow(noise(vec2(time*99., 0.)), 9.));\n    }\n    else\n    {\n        \/\/ bam\n        float c = clamp(1.-(time-2.5)*6., 0., 1. );\n        col = mix(col, vec3(1.,1.,1.),c);\n    }\n#endif\n    \n    \/\/ Vignetting\n\tvec2 xy2 = gl_FragCoord.xy \/ iResolution.xy;\n\tcol *= vec3(.5, .5, .5) + 0.25*pow(100.0*xy2.x*xy2.y*(1.0-xy2.x)*(1.0-xy2.y), .5 );\t\n\n\tfragColor = vec4(col,1.0);\n}\n","name":"Image","description":"","type":"image"}]}]